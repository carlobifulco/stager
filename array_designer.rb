require "rinruby"
require "pathname"
require 'prawn' 
require 'stringio'
require "rsruby"

RSRuby.set_default_mode RSRuby::NO_CONVERSION
$r=RSRuby.instance

if RUBY_VERSION > "1.9"    
 require "csv"  
 unless defined? FCSV
   class Object  
     FCSV = CSV 
     alias_method :FCSV, :CSV
   end  
 end
else
 require "fastercsv"
end

begin 
  $FILENAME=ARGV[0]
rescue
  puts "I NEED A CSV FILE NAME!!!"
  
$FIELD_TO_SCAN= "DIAGNOSIS_TEXT"


puts "no deletes row; yes approves"

#ENCOUNTERNUMBER	CORPORATENUMBER	PATIENTNAME	DOB	SEX	CASE_NUMBER	CASE_REPORTING_DATE	SPECIMENTYPE	
#REPORT_SECTION	ORDERING_PROVIDER	REPORT_TAT	RESPONSIBLE_PATHOLOGIST	CASE_STATUS	SIGNED_DT	DIAGNOSIS_TEXT	AGEATOBSERVATION

def para text
  a=text.split
  f=[]

  a.each do |x|
      f << x
      if (f.join(" ").split "\n")[-1].length/7 > 8
      
      
        f<< "\n"
      elsif x.index "*"
        f<< "\n"
      end
  end
  f.join " "
end



class Stager
  
  attr_accessor :table, :r, :c
  
  def initialize(year,file_name="./test.csv")
    @file_name=file_name
    @year=year
    @new_file_name="#{@year.to_s}_#{(Pathname.new @file_name).basename.to_s}"
    self.clean_file
    self.get_year
  end
    
  def clean_file
   if File.readable? @file_name
      @c=CSV.read(@file_name,headers:true)
      if @c.headers[-1]==nil
        @c.by_col!
        @c.delete(-1)
        puts "DELETED NIL COLUMN"
      end
      save_c @c.to_a, @file_name
      @c=CSV.table @file_name
    else
      puts "could not find your file"
    end
  end
   
  def get_all
    @c
  end
  
  def get_sv 
    #SP, SV
    @c.select{|row| (row[:case_number].split("-"))[0]=="SV"}
  end
  
  def get_sp
    #SP, SV
    @c.select{|row| (row[:case_number].split("-"))[0]=="SP"}
  end
  
  def get_not_sv_sp
    @c.select{|row| (not ["SV","SP"].member? row[:case_number].split("-")[0])}
  end
  
  def get_year 
    #dump date format "1/3/2006 15:08" OTHER FORMATS GENERATED BY NUMBERS
    s=@c.select{|row| row[:case_reporting_date].split()[0].split("/")[-1]==@year.to_s}
    @c=s
    # c_new=[]<<@c.headers.join(",")
    # c_row=@c.by_row
    # 0.upto(@c.length-1).each do |i|
    #   if (@c[:case_reporting_date][i].split()[0].split("/")[-1]) ==@year.to_s
    #     c_new<<c_row[i].to_s 
    #   end
    #   puts i
    # end
    # 
    # save_c c_new, @new_file_name
    # @c=CSV.table @new_file_name
    # #c_new
  end

  def save_c c_array, file_name
    CSV.open(file_name,"w") do |csv|
      c_array.each do |row|
        row=(CSV.parse_line row) if row.class==String
        csv<<row
      end
    end 
  end
  
  def get_title
    split=@new_file_name.split("_")
    "#{split[1].capitalize} Cancer #{split[0]}"
  end
  

end

class Plotter
  
  attr_accessor :s,:stage,:summary
  
  def initialize table_array, title
    @title=title
    @table_array=table_array
    @stage=get_T
    #plot stager_obj.get_T, stager_obj.get_title
  end
  
  def get_T 
    @s=[]
    @f=[]
    pattern=/.(T\d)./
    
    @table_array.each do |row|
      @s<<(row[:diagnosis_text].match pattern)[1] if (row[:diagnosis_text].match pattern)
      @f<<row if not (row[:diagnosis_text].match pattern)
    end
    puts "Tot= #{@table_array.length}; found Ts =#{@s.length};  failures=#{(@f.length)}"
    @s=@s.map{|i| "p"+i.to_s}
    puts @s
    @s.select!{|i| i if (i[2].to_i>0 and i[2].to_i<5)} #remove T0 and T5...
    @summary=$r.summary($r.factor(@s,{:order=>"T"}))
    return @s
  end
  
  def plot xlim
    $r.barplot($r.summary($r.factor(self.get_T,{:order=>"T"})),{:xlim=>[0,xlim],:horiz=>"True", :cex_names=>1})
    
    #$r.barplot(get_T,{:horiz=>"True", :cex_names=>1})
    $r.title({:main=>@title,:xlab=>"Cases #",:ylab=>"Stage"})
     
    # $r.factor
    #     $r.barplot(@r.summary(@r.factor(t,order=T)))
    #R.res=t
    #R.eval("barplot(summary(factor(res, order=T)),main='#{title}',ylab='n.cases',xlab='stage')")
  end
end


class MasterPlotter
  
  attr_accessor :s,:graphs, :xlim

  def initialize (year,file_name="./test.csv")#(file_name="./subset_prostate_dump_prostatectomy_only.csv")
    @file_name=file_name
    @s=Stager.new(year,@file_name)
    $r.par({:mfrow=>[4,1]})
    $r.par({:las=>2}) 
    $r.par({:mar=>[5,8,4,2]})
    @graphs=[]
    self.load_graphs
  end
  
  def get_xlim
    @xlim=[]
    @graphs.each do |g|
      @xlim<<[g.s.select{|x| x=="pT1"}.length,
        g.s.select{|x| x=="pT2"}.length,
        g.s.select{|x| x=="pT3"}.length,
        g.s.select{|x| x=="pT4"}.length].max
    end
    @xlim.max
  end
  def load_graphs
    @graphs<<g1=(Plotter.new @s.get_all,"#{@s.get_title} PSA")
    @graphs<<g2=(Plotter.new @s.get_sv, "#{@s.get_title} PSV")
    @graphs<<g3=(Plotter.new @s.get_sp,"#{@s.get_title} PPMC")
    @graphs<<g4=(Plotter.new @s.get_not_sv_sp, "#{@s.get_title} NOT PSA-PPMC")
  end
  
  def show_plot
    @graphs.each do |g|
      begin
        g.plot self.get_xlim
      rescue
      end
    end
  end
  
  def save_png_plot
    $r.dev_off()
    pdf_file_name=(@s.get_title.split.join "_")+".png"
    puts pdf_file_name
    # width = 480, height = 480, units = "px",
    $r.png({:file=>"#{pdf_file_name}",:width=>800,:height=>800,:pointsize=>18})
     #$r.png({:file=>"#{pdf_file_name}",:width=>7.54,:height=>7.54,:pointsize=>18,:units=>"in"})
    $r.par({:mfrow=>[4,1]})
    $r.par({:las=>2}) 
    $r.par({:mar=>[5,8,4,2]})
    @graphs.each do |g|
      begin
       g.plot self.get_xlim
      rescue
      end
    end
    $r.dev_off()
    self.show_plot
    # R.eval("pdf(file=file_name)")
    # R.eval("plot(plot_data)")
    # R.eval("dev.off()")
  end
  
  def save_pdf_plot
    $r.dev_off()
    pdf_file_name=(@s.get_title.split.join "_")+".pdf"
    puts pdf_file_name
    # width = 480, height = 480, units = "px",
    $r.pdf({:file=>"#{pdf_file_name}",:paper=>"a4"})
    $r.par({:mfrow=>[4,1]})
    $r.par({:las=>2}) 
    $r.par({:mar=>[5,8,4,2]})
    @graphs.each do |g|
       g.plot self.get_xlim
     end
    $r.dev_off()
    self.show_plot
    # R.eval("pdf(file=file_name)")
    # R.eval("plot(plot_data)")
    # R.eval("dev.off()")
  end
  
end



class ArrayDesigner
  
  # size [number of rows,number of columns]
  attr_reader :n_array_rows,:n_array_cols,:array_data
  def initialize(n_array_rows,n_array_cols, array_data)
    @n_array_rows,@n_array_cols=n_array_rows,n_array_cols
  end
  
  def circles
    
  end
  
  def text
    
  end
  
  def tables
    
  end
  
end



def make_rows_headers
  header=[0]
  (%w"a b c d e f".each {|x| x.capitalize!}).each do |x|
    (1..4).each do |n|
    header << "#{x}#{n}"
    puts header
    end
  end
  return header
end



module CsvMethods
  
  def load_csv filename
    csv_handle=CSV.open(filename)
    header=csv_handle.readline
    return header, csv_handle
  end
  
  def get_headers_positions(eliminate, header)
   eliminate_positions=[]
    eliminate.each do |elim|
      eliminate_positions<<header.index(elim)
    end
    eliminate_positions
  end
  

  def anonymize (header_csv_handle)
    # header list and csv
    header=header_csv_handle[0]
    csv_handle=header_csv_handle[1]
    new_lines=[]
    eliminate=["ENCOUNTERNUMBER","CORPORATENUMBER","PATIENTNAME","DOB","CASE_REPORTING_DATE",
      "REPORT_SECTION", "ORDERING_PROVIDER","REPORT_TAT", "RESPONSIBLE_PATHOLOGIST",
      "CASE_STATUS","SIGNED_DT"]
    eliminate_positions=get_headers_positions(eliminate,header)
    lines=csv_handle.readlines()
    lines.each do |line|
        new_line=line.collect {|field| field if not (eliminate_positions.include?(line.index(field)))}.compact
        puts new_line
        puts line.length
        new_lines<<new_line
    end
    eliminate.each do |e|
      header.delete(e)
    end
    
    new_cvs=[(header.join(","))].concat new_lines
    new_cvs
    
    # a.collect {|x| x if ([1,0,4].include?(a.index(x)))}.compact
    
    
    # eliminate.each do |e|
    #   header.eliminate e
    # end
    # do |line|
    #   eliminate_positions.each do |position|
    #     line.delete_if (position)
    #     new_lines<<line
    #   end
    # 
    # end
    # new_cvs+=header
    # new_cvs+=new_lines
    # return header, new_lines,eliminate
  end
  
  def run filename
    write_file (screen_by_diagnosis(load_csv filename))  
  end
  
  def screen_by_diagnosis (header, csv_handle)
    100.times {puts "\n"}
    new_file=[]<<header
    all=csv_handle.readlines()
    all.each do |line|
     puts para line[POSITION]
     puts "\n"
     puts "yes or no"
     answer=STDIN.readline
     case answer
      when "yes\n"
        puts "YES"
        new_file<<line
      when "no\n"
        puts "NO"
      else
        puts "COULD NOT FIND IT #{answer}"
      end
    100.times {puts "\n"}
    end 
    all
  end

  def write_file line_array
    fh=CSV(File.open FILENAME, "w+")
    line_array.each do |line|
    fh.puts line
    end
    fh.close
  end
end
end

class ArrayDesigner
  include CsvMethods
  
  attr_accessor :cvs, :file_name
  
  def initialize(file_name="./subset_prostate_dump_prostatectomy_only.csv")
        @header,@csv_handle=load_csv file_name
        @cvs=anonymize([@header,@csv_handle])
        @file_name=file_name      
  end
  
  def add_row_label 
    new_cvs=[]
    make_rows_headers.each_with_index do |x,i|
      if i==0
        new_cvs<<(","+(@cvs[i])).split(",")
        next
      end
      new_cvs<<([x]+@cvs[i])
    end
    @cvs=new_cvs
  end
  
  def write_file
    new_file_name="anon_"+(Pathname.new @file_name).basename.to_s
    CSV.open(new_file_name,"w") do |csv|
      @cvs.each do |line|
        csv<<line
      end
    end
  end
  
  def show_file
    Prawn::Document.generate("test.pdf", :page_layout=>:landscape) do 
      t= CSV.read(@file_name,headers: true,header_converters: :symbol)
      headers=t.headers
      entries=t.entries
      table entries, :headers=>headers, font_size=>10,:position=>center
    end
  end

  
end
